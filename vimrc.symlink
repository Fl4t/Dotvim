" Pathogen 2.0"{{{
filetype off
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect() " Activer pathogen
call pathogen#helptags() " Sourcing help file
filetype plugin indent on
set nocompatible       " leave the old ways behind...
"}}}
"Couleurs"{{{
syntax on               " activer les couleurs
colorscheme solarized   " colorscheme
set bg=dark             " version sombre de solarized
"}}}
"General"{{{
set complete=.,w,b,t   " paramètre de complétion
set history=400        " historique des commandes vim
set shell=/bin/zsh     " langage shell par défaut
set encoding=utf-8     " UTF-8
set fileencoding=utf-8 " UTF-8
set fileformat=unix
set backspace=2        " règle le comportement de backspace
set mouse=a            " active la souris pour toujours
set mousehide          " hide mouse when typing
let mapleader=","      " change la touche par défaut de vim qui est \
set clipboard=unnamed  " yank et aussi copier en mémoire tampon
set shellslash         " c'est Derek qui le dit alors chut.
set cpoptions+=$       " pour avoir un dollars lorsque l'on change, touche c
set virtualedit=all    " pour ce déplacer même si il n'y a pas de caractère
set lazyredraw         " Don't update the display while executing macros
set gdefault           " Ne pas taper le g de /truc/truc/g
set nospell            " pas de correction orthographique par défaut
"}}}
"Interface"{{{
"set relativenumber            " Numero de ligne dynamique à la position
set number                    " (temporaire) relativenumber lag trop
set numberwidth=1             " 1 ligne = 1 numéro
set shortmess=aTi             " format of messages (avoids 'hit enter')
set viewoptions=folds,options,cursor,unix,slash " better unix / windows compatibility"
set noshowmode                " vim-powerline le fait très bien
set wildmenu                  " menu en carré
set wim=list:longest,full     " la tronche des possibilité de complétion
set wildignore=*.o,*.bak,*.pyc,*.swp,*.jpg,*.gif,*.png
set visualbell t_vb=          " pas de clignotement
set noerrorbells              " pas de clignotement quand erreur
set guicursor=a:blinkon0      " pas de curseur qui clignote
set cmdheight=2               " 1 ligne en dessous de statusline
set laststatus=2              " toujours voir la barre de statut
"}}}
"Indentation"{{{
set expandtab           " insère des espaces au lieu de tab
set tabstop=2           " nombre d'espaces par tab
set softtabstop=2       " nombre d'espace pour une tab en mode édition
set shiftwidth=2        " pareil mais pour >> <<
set shiftround          " tab toujours multiple de shiftwidth
"}}}
"Édition"{{{
set nostartofline                   " conserve la colonne
let g:loaded_matchparen=1           " désactive le sur-lignage des paires de parenthèses
set scrolloff=999                   " laisser des lignes en dessus et dessous"
set nowrap                          " pas de retour a la ligne par défaut
set diffopt=filler,iwhite,vertical  " Options pour le mode diff

" Permet de voir les espaces et tab en trop
set nolist
set listchars=tab:▸\ ,trail:✖,eol:¬,extends:❯,precedes:❮
"}}}
"Replis"{{{
set foldenable          " ferme les replis existant par défaut
set foldmethod=marker   " c'est les marqueurs qui délimite les replis
set foldminlines=2      " nombre de ligne mini pour replis
set fillchars=fold:·    " affiche des ... après le nom du replis

" Ces commandes ouvre les replis
set foldopen=block,insert,jump,mark,percent,quickfix,search,tag,undo
"}}}
" Commandes"{{{

" Re-selectionner le texte précédemment collé
nnoremap <leader>v V`]

" Backquotes -> é
noremap é `

" Display-wise up/down movement instead of linewise.
noremap j gj
noremap k gk

" Permet de placer au milieu de l'écran l'occurence de la recherche
nnoremap n nzzzv
nnoremap N Nzzzv

" Permet d'aller au debut et a la fin d'une ligne plus facilement
noremap H ^
noremap L g_

" Focus le replis ou je suis"
nnoremap <leader>z zMzvzz

" Aller au dossier du fichier courant
nnoremap ,cd :cd %:p:h<CR>:pwd<CR>

" Mapping pour éditer le vimrc et le sourcer
nmap <silent> <leader>ev :vsplit $MYVIMRC<CR> " Modifier le vimrc
nmap <silent> <leader>sv :so $MYVIMRC<CR> " Sourcer le vimrc

" faute suivante/précédente
map <leader>fn ]s
map <leader>fp [s

" Use the arrows to something usefull
map <right> :bn<cr>
map <left> :bp<cr>

" Use Q for formatting the current paragraph (or visual selection)
vmap Q gq
nmap Q gqap

" contraire de [J]oin
nnoremap S i<cr><esc><right>

" Completion de fichiers
inoremap <c-f> <c-x><c-f>

" Completion de lignes
inoremap <c-l> <c-x><c-l>

" Utiliser p en mode visuel pour remplacer le texte sélectionne par le texte
" yanker précédemment
vnoremap p <Esc>:let current_reg = @"<CR>gvdi<C-R>=current_reg<CR><Esc>

"simple matching pairs easily, with Tab
nnoremap <Tab> %
vnoremap <Tab> %

" awesome, inserts new line without going into insert mode
map <S-Enter> O<ESC>
map <Enter> o<ESC>

" permet de pouvoir enregistrer sans taper sudo
cmap w!! w !sudo tee % > /dev/null

" Récupère la sélection après une indentation shift
vnoremap <silent> < <gv
vnoremap <silent> > >gv

" Enlève le sur-lignage après une recherche en tapant espace
noremap <silent> <Space> :silent noh<Bar>echo<CR>

" Navigation des fenêtres facile
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l

" Diff.
nnoremap <silent><Leader>do :diffoff!<CR>
nnoremap <silent><Leader>dg :diffget<CR>:diffupdate<CR>
nnoremap <silent><Leader>dp :diffput<CR>:diffupdate<CR>
nnoremap <silent><Leader>du :diffupdate<CR>

" mapping français
map <silent> <F1> "<Esc>:silent setlocal spell! spelllang=fr<CR>"

" Voir les espaces/tab en trop
nnoremap <F3> :set nolist!<CR>

" Mode copier/coller
nnoremap <F4> :set paste!<CR>
"}}}
" autoCommand"{{{
if has("autocmd")

  " Auto-cd au répertoire root si il existe, courant sinon
  function! s:setcwd()
    let cph = expand('%:p:h', 1)
    if cph =~ '^.\+://' | retu | en
    for mkr in ['.git/', '.hg/', '.svn/', '.bzr/', '_darcs/', '.vimprojects']
      let wd = call('find'.(mkr =~ '/$' ? 'dir' : 'file'), [mkr, cph.';'])
      if wd != '' | let &acd = 0 | brea | en
    endfo
    exe 'lc!' fnameescape(wd == '' ? cph : substitute(wd, mkr.'$', '.', ''))
  endfunction

  autocmd BufEnter * call s:setcwd()

  " Plugin VB.NET highlighting
  au BufNewFile,BufRead *.vb set ft=vbnet

  " Moteur de template twig
  au BufNewFile,BufRead *.twig set ft=htmldjango

  " Supprime automatiquement les espaces de fin de ligne
  au BufWritePre * :%s/\s\+$//e

  " saute a la dernière position du curseur sauf pour les commits
  au BufReadPost *
      \ if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$") |
      \ execute 'normal! g`"zvzz' |
      \ endif

  " Fonctions pour fichiers LaTeX
  au BufEnter,BufNewFile *.tex	exe Flatex()

  " Fonctions pour fichiers C
  au BufEnter,BufNewFile *.c	exe FlangageC()

  " Fonctions pour fichiers Java
  au BufEnter,BufNewFile *.java exe Fjava()
endif
"}}}
"Recherche"{{{
set hlsearch            " surligne les recherches
set incsearch           " increment search
set ignorecase          " case-insensitive search
set smartcase           " uppercase causes case-sensitive search
"}}}
"Buffer/Fenêtres/Tabs"{{{
set hidden          " Pour pouvoir changer de buffer sans sauvegarder
set wmh=1           " Nombre minimal de lignes pour une fenêtre
set splitbelow      " ouvre un nouveau fichier en dessous du précédent
"}}}
"Fichier/Backup"{{{
set undofile    " undo fonctionne après avoir fermé le fichier
set autoread    " recharge auto quand un fichier est modifié
set autowrite   " sauvegarde auto quand on change de buffer
set backup      " sauvegarde
set writebackup " écrit le backup avant d'écrire le vrai fichier
set backupdir=$HOME/Documents/vimsave/savefile " dossier des .backup
set directory=$HOME/Documents/vimsave/swapfile " dossier des .swp
set undodir=$HOME/Documents/vimsave/undofile   " dossier des .un

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif
"}}}
"Plugins"{{{
" Powerline"{{{
set rtp+=~/.powerline/powerline/bindings/vim
if ! has('gui_running')
    set ttimeoutlen=10
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif
"}}}
" Syntastic"{{{
let g:syntastic_quiet_warnings=1
let g:syntastic_error_symbol='✗'
let g:syntastic_enable_balloons = 0
"}}}
" Plugin Gundo"{{{
nnoremap <silent> <F10> :GundoToggle<CR>
"}}}
" Fugitive"{{{
noremap <leader>gs :Gstatus<CR>
noremap <leader>gd :Gdiff<CR>
noremap <leader>gc :Gcommit<CR>
noremap <leader>gb :Gblame<CR>
noremap <leader>gl :Glog<CR>
"}}}
" Clam easier"{{{
nnoremap ! :Clam<space>
vnoremap ! :ClamVisual<space>
"}}}
" CtrlP"{{{
nnoremap <leader>b :CtrlPBuffer<CR>
nnoremap <leader>m :CtrlPMRUFiles<CR>
nnoremap <leader>t :CtrlP<CR>

let g:ctrlp_mruf_exclude = '/tmp/.*\|/temp/.*\|/private/.*' " MacOSX/Linux

let g:ctrlp_custom_ignore = {
	\ 'dir':  '\v[\/]\.(git|hg|svn)$',
	\ 'file': '\v\.(exe|so|dll|class)$',
	\ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
	\ }
"}}}
  "Neocomplcache"{{{
if exists('g:loaded_neocomplcache')
  " Disable AutoComplPop.
  let g:acp_enableAtStartup = 0
  " Use neocomplcache.
  let g:neocomplcache_enable_at_startup = 1
  " Use smartcase.
  let g:neocomplcache_enable_smart_case = 1
  " Use camel case completion.
  let g:neocomplcache_enable_camel_case_completion = 1
  " Use underbar completion.
  let g:neocomplcache_enable_underbar_completion = 1
  " Set minimum syntax keyword length.
  let g:neocomplcache_min_syntax_length = 3
  let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

  " Define dictionary.
  let g:neocomplcache_dictionary_filetype_lists = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

  " Define keyword.
  if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
  endif
  let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplcache#undo_completion()
  inoremap <expr><C-l>     neocomplcache#complete_common_string()

  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr><C-y>  neocomplcache#close_popup()
  inoremap <expr><C-e>  neocomplcache#cancel_popup()

  " AutoComplPop like behavior.
  "let g:neocomplcache_enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplcache_enable_auto_select = 1
  "let g:neocomplcache_disable_auto_complete = 1
  "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<TAB>"
  "inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"

  " Enable omni completion.
  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

  " Enable heavy omni completion.
  if !exists('g:neocomplcache_omni_patterns')
    let g:neocomplcache_omni_patterns = {}
  endif
  let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
  "autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
  let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
  let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'
endif"}}}
"hexhighlight"{{{
nmap <leader>h :call HexHighlight()<Return>
"}}}
" LanguageTool"{{{
let g:languagetool_jar=$HOME.'/.languagetool/LanguageTool.jar'
"}}}
" NERDTree"{{{
nnoremap <silent> <F11> :NERDTreeToggle<CR>

" Show the bookmarks table on startup
let NERDTreeShowBookmarks=1
" Don't display these kinds of files
let NERDTreeIgnore=[ '\.class$', '\.ncb$', '\.suo$', '\.vcproj\.RIMNET', '\.obj$',
      \ '\.ilk$', '^BuildLog.htm$', '\.pdb$', '\.idb$',
      \ '\.embed\.manifest$', '\.embed\.manifest.res$',
      \ '\.intermediate\.manifest$', '^mt.dep$' ]
"}}}
" Plugin Tagbar"{{{
nnoremap <silent> <F12> :TagbarToggle<CR>
let g:tagbar_width = 31 " like NERDTree
if !has("mac")
  let g:tagbar_ctags_bin = $HOME.'/bin/ctags'
endif

"}}}
"}}}
"Langages"{{{
"Langage C"{{{
fun! FlangageC()
  noremap <leader>C <c-\><c-n>:!gcc -Wall % -o %<.x<cr>
  setlocal formatoptions-=c formatoptions-=r formatoptions-=o
endf
"}}}
"PHP"{{{
let php_baselib = 1
let php_htmlInStrings = 1
let php_noShortTags = 1
let php_folding = 1
let php_parent_error_close = 1
"}}}
"LaTeX"{{{
function! Flatex()
  " Largeur de texte standard
  set tw=72

  " filetype
  set ft=tex

  " Activer la correction dans les fichier tex
  setlocal spell spelllang=fr

  " Sauvegarde et compilation PDFLaTeX (-> PDF)
  noremap <leader>C <ESC>:w<CR>:!pdflatex %<.tex<CR><CR>

  " Voir le pdf créé
  noremap <leader>pdf <ESC>:w<CR>:!open %<.pdf<CR><CR>
endfunction
"}}}
"Java"{{{
function! Fjava()
  " Sauvegarde et compilation
  noremap <leader>C <ESC>:w<CR>:!javac %<CR>
endfunction
"}}}
"}}}
"Custom Functions"{{{

" Toggle relative/absolute numbering
nnoremap <F2> :call NumberToggle()<CR>

function! NumberToggle()
  if(&relativenumber == 1)
    set number
  else
    set relativenumber
  endif
endfunc
"}}}
"Next and Last"{{{
"
" Motion for "next/last object". "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type in the current line, last acts
" on the previous object of the given type in the current line.
"
" Currently only works for (, [, {, b, r, B, ', and ".
"
" din' -> delete in next single quotes foo = bar('spam')
" canb -> change around next parens foo = bar('spam')
" vil" -> select inside last double quotes print "hello ", name
onoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>

function! s:NextTextObject(motion, dir)
  let c = nr2char(getchar())

  if c ==# "b"
    let c = "("
  elseif c ==# "B"
    let c = "{"
  elseif c ==# "r"
    let c = "["
  endif

  exe "normal! ".a:dir.c."v".a:motion.c
endfunction
"}}}
